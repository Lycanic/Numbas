<!DOCTYPE html>
<!--
Copyright 2023 Newcastle University

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<html lang="{{options.locale}}">
    <head>
        {% with dont_start_exam = True %}
        {% include 'head.html'  %}
        {% endwith %}
        <style>
            .table_options {
                display:flex;
            }
        </style>
	</head>
	
    <body>
        <div id = data_display>
            <div class = table_options>
                <div>   
                    <label for="student_results">Choose student results files</label> <!--data=document.querySelector('student_results').files[0], await data.text()-->
                    
                    <input type="file"
                    id="student_results" name="student_results"
                    accept=".txt" multiple data-bind="event: {change: function() {add_files($element.files)}}"> <!--file_array.push($element.files[0])-->
                </div>
                <div>   
                    <button data-bind = "click: download_decrypted_files">Download Decrypted Files</button>
                    <button data-bind = "click: download_table">Download Displayed Table</button>
                </div>
                <div>
                    <label for = "totalOnly">Total Only</label>
                    <input type = "checkbox" name = "totalOnly" data-bind = "checked: column_display_presets().total_only().applied">

                    <label for = "hide_parts">Hide Parts</label>
                    <input type = "checkbox" name = "hide_parts" data-bind = "checked: column_display_presets().hide_parts().applied">

                    <label for = "hide_gaps_and_steps">Hide Gaps and Steps</label>
                    <input type = "checkbox" name = "hide_gaps_and_steps" data-bind = "checked: column_display_presets().hide_gaps_and_steps().applied">

                    <label for = "hide_answers">Hide Answers</label>
                    <input type = "checkbox" name = "hide_answers" data-bind = "checked: column_display_presets().hide_answers().applied">
                </div>
            </div>
            <div class = table_display>
                
                <table>
                    <!-- To hide columns individually: -->
                    <!-- <tr data-bind = "foreach: table_header_computer_filtered"><td><button data-bind = "click: function() {$root.hide_column_by_name($data)}">Hide</button></td></tr>-->
                    <tr data-bind = "foreach: table_header_webpage"><th data-bind="text: $data"></th></tr>
                    <tbody data-bind = "foreach: table_body">
                        <tr data-bind = "foreach: $data">
                            <td data-bind = "text: $data"></td>
                        </tr>
                    </tbody>
                </table>
            </div>

        </div>
        <script>
            const viewModel = {
                uploaded_files: ko.observableArray(),
                decrypted_files: ko.observableArray(),
                table_header_readable: ko.observableArray(),
                table_header_computer: ko.observableArray(),
                hidden_rows: ko.observableArray(),
                passcode: ko.observable(''),
                /** An object with various presets such as 'show everything' and 'total score only'. Each element should itself be an object containing a 
                 *  true/false as to whether it is enforced and the effect it would have on the show_columns vector.
                 * */
                column_display_presets: ko.observable({all_data: ko.observable({applied: ko.observable(true), shown_columns: ko.observable([])}), //all_data should *always* be true, it is the baseline. false will be ignored.
                                         total_only: ko.observable({applied: ko.observable(false), shown_columns: ko.observable([])}), 
                                         hide_answers: ko.observable({applied: ko.observable(false), shown_columns: ko.observable([])}), 
                                         hide_gaps_and_steps: ko.observable({applied: ko.observable(false), shown_columns: ko.observable([])}), 
                                         hide_parts: ko.observable({applied: ko.observable(false), shown_columns: ko.observable([])}), 
                                         custom: ko.observable({applied: ko.observable(false), shown_columns: ko.observable([])})}),
                add_files: async function(files) {
                    for (let file of files) {
                        try {
                            let decrypted = await this.decrypt_file(file);
                            this.uploaded_files.push(file);
                            this.decrypted_files.push(decrypted);
                        }
                        catch(err) {
                            //decrypt_file will error if the seed is wrong, and then we don't add the files to the storage.
                            alert(`Error handling file ${file.name}, ensure these files are for this exam.`)
                        }
                    }
                },
                decrypt_file: async function(file) { //big question - when do we fix the question ordering? Perhaps the decrypted files should have the correct ordering already
                            let text = await Numbas.download.decrypt(Numbas.download.b64decode(await file.text()),viewModel.passcode());
                            let filename = file.name.replace(".txt",".csv");
                            let content = this.parse_csv_to_arrays(text);
                            return {text: text,filename: filename,content: content}
                },
                download_decrypted_files: function() {
                    for (let file of this.decrypted_files()) {
                        Numbas.download.download_file(file.text, file.filename);
                    }
                },
                download_table: function() {
                    let table_body = this.table_body().map(((x) => x)); //shallow copy - but means the later unshifts don't mess with the body itself!
                    table_body.unshift(this.table_header_webpage());
                    table_body.unshift(this.filter_columns([this.table_header_computer()])[0]);
                    let filename = "exam_results.csv";
                    let content = Numbas.csv.from_array(table_body);
                    Numbas.download.download_file(content, filename);
                },
                parse_csv_to_arrays: function(csv) {
                    let rows = Numbas.csv.split_csv_into_cells(csv);
                    return rows;
                },
                hide_column: function(column_number) {
                    let shown_columns = this.column_display_presets().custom().shown_columns();
                    shown_columns[column_number] = false;
                    this.column_display_presets().custom().shown_columns(shown_columns);
                    if (!this.column_display_presets().custom().applied()){
                        this.column_display_presets().custom().applied(true);
                    }
                },
                hide_column_by_name: function(column_name) {
                    let column_index = this.table_header_computer().indexOf(column_name);
                    this.hide_column(column_index);
                },
                unhide_column: function(column_number) {
                    let shown_columns = this.column_display_presets().custom().shown_columns();
                    shown_columns[column_number] = true;
                    this.column_display_presets().custom().shown_columns(shown_columns);
                },
                hide_row: function(row_number) {
                    if (this.hidden_rows.indexOf(row_number)==-1){
                        this.hidden_rows.push(row_number);
                    }
                },
                unhide_row: function(row_number) {
                    this.hidden_rows.remove(row_number);
                    
                },
                filter_columns: function(table){
                    let new_table = table.map(row => {
                        new_row = row.filter((cell,index) => {
                            return viewModel.show_columns()[index];
                        });
                        return new_row;
                    });
                    return new_table;},
                apply_preset: function(preset_name) {
                    if (preset_name == 'all data') {
                        let all_presets = this.column_display_presets()
                        for (preset in all_presets) {
                            all_presets[preset]().applied(false);
                        }
                        this.column_display_presets().all_data().applied(true);
                        this.hidden_rows.removeAll();
                        return;
                    }
                    if (preset_name == 'total score only') {
                        this.column_display_presets().total_only().applied(true);
                        this.full_table().forEach((row,index) => {
                            if (row[0]==R('exam.csv.expected')) {
                                this.hidden_rows.push(index);
                            }
                        });
                    } 
                    if (preset_name == 'hide parts') {
                        this.column_display_presets().hide_parts().applied(true);
                    } 

                },
                /**
                 * Rearranges the order of data (and inserts empty columns) to match the original ordering
                 * 
                 *  @param content the array of student data
                 *  @returns the array of student data in the same order as the headers
                 * 
                 * */
                match_order: function(content) {
                    let header_computer = content[0];
                    let matched_ordering = []; //how do I want this to work? Is this a mapping from content to original or original to content?
                    for (let item of this.table_header_computer()) {
                        let index = header_computer.indexOf(item);
                        matched_ordering.push(index) //if not found it will be -1, we can deal with that later!
                    }
                    let new_content = [];
                    for (let row of content) {
                        new_row = [];
                        for (let item of matched_ordering) {
                            if (item==-1){
                                new_row.push("")
                            }
                            else {
                                new_row.push(row[item])
                            }
                        }
                        new_content.push(new_row);
                    }
                    return new_content;
                }
            };

            viewModel.full_table = ko.computed(function() {
                    //needs to be initialised after the rest of viewModel so it can access decrypted_files()
                    let full_table = [];
                    for (let file of viewModel.decrypted_files()) {
                        let file_with_matched_order = viewModel.match_order(file.content);
                        file_with_matched_order.forEach(data => {
                            if (data[0]==R('exam.csv.expected') ||data[0]==R('exam.csv.student') ) {
                                full_table.push(data)
                            }
                            return;
                        });
                    }
                    return full_table;
                }, this);

            viewModel.show_columns = ko.computed(function() {
                let presets = viewModel.column_display_presets();
                let shown_columns = presets.all_data().shown_columns();
                for (preset in presets) {
                    if (presets[preset]().applied() == true) {
                        shown_columns = shown_columns.map((value,index) => {
                            return value && presets[preset]().shown_columns()[index];
                        });
                    } 
                }
                return shown_columns;
            },this);

            viewModel.table_body = ko.computed(function() {
                    let full_table = viewModel.full_table();
                    let new_table = viewModel.filter_columns(full_table);
                    new_table=new_table.filter((row,index) => {
                            if (viewModel.hidden_rows().indexOf(index)==-1) {
                                return true;
                            }
                                return false;                        
                    });
                    return new_table;
                }, this);
            
            viewModel.table_header_webpage = ko.computed(function() {
                let full_header = viewModel.table_header_readable();
                let new_header = viewModel.filter_columns([full_header]);
                return new_header[0];
            }, this);

            viewModel.table_header_computer_filtered = ko.computed(function() {
                let full_header = viewModel.table_header_computer();
                let new_header = viewModel.filter_columns([full_header]);
                return new_header[0];
            }, this);
                
            
            const examData = {
                set_exam_details_from_json: async function() {
                    let retrieved_source = await (await fetch(`source.exam`)).text();
                    let split_source = retrieved_source.substring(retrieved_source.indexOf("\n")+1);
                    let exam_object = examData.exam_object = JSON.parse(split_source);
                    let originalOrder = [R('exam.csv.question key'),R('exam.csv.student name'),R('exam.csv.total score')];
                    let humanReadableOrder = [R('exam.csv.question name'),R('exam.csv.student name'),R('exam.csv.total score')];
                    exam_object.question_groups.forEach((group_object, group_index) => {
                        let group_label = 'r'+ group_index;
                        group_object.questions.forEach((question_object,question_index) => {
                            let questionKey = question_index;
                            let questionName = question_object.name;
                            let groupName = R('exam.csv.group')+ " " + group_index;
                            let question_label = group_label+'q'+question_index;
                            originalOrder.push(question_label);
                            humanReadableOrder.push(questionName);

                            question_object.parts.forEach((part_object,part_index) => {
                                let partKey = part_index;
                                let partName = part_object.name || (R('part') + " " + partKey);
                                let partType = part_object.type;
                                let part_label = question_label + 'p' + part_index;
                                originalOrder.push(part_label+"m");
                                humanReadableOrder.push(partName+" Marks")
                                if (partType != 'gapfill') {
                                    originalOrder.push(part_label+"a");
                                    humanReadableOrder.push(partName+" Answer")
                                }
                                part_object.gaps?.forEach((gap_object,gap_index) => { //if optional chaining is not supported, update to full if.
                                    let gapKey = gap_index;
                                    let gapName = gap_object.name || (R('gap') + " " + gapKey);
                                    let gapType = gap_object.type;
                                    let gap_label = part_label + 'g' + gap_index;
                                    originalOrder.push(gap_label+"m");
                                    originalOrder.push(gap_label+"a");
                                    humanReadableOrder.push(gapName+" Marks")
                                    humanReadableOrder.push(gapName+" Answer")
                                });
                                part_object.steps?.forEach((step_object,step_index) => {
                                    let stepKey = step_index;
                                    let stepName = step_object.name || (R('step') + " " + stepKey);
                                    let stepType = step_object.type;
                                    let step_label = part_label + 'g' + step_index;
                                    originalOrder.push(gap_label+"m");
                                    originalOrder.push(gap_label+"a");
                                    humanReadableOrder.push(stepName+" Marks")
                                    humanReadableOrder.push(stepName+" Answer")
                                });
                            });
                        });
                    });
                    ko.utils.arrayPushAll(viewModel.table_header_computer,originalOrder);
                    ko.utils.arrayPushAll(viewModel.table_header_readable,humanReadableOrder);
                    viewModel.column_display_presets().all_data().shown_columns(originalOrder.map((x) => true));
                    viewModel.column_display_presets().total_only().shown_columns(originalOrder.map((x, index) => {
                        if (index == 1 || index == 2) {
                            return true;
                        }
                        return false;
                    }));
                    viewModel.column_display_presets().hide_answers().shown_columns(originalOrder.map((x) => {
                        if (x.slice(-1)=='a') {
                            return false;
                        }
                        return true;
                    }));
                    viewModel.column_display_presets().hide_gaps_and_steps().shown_columns(originalOrder.map((x) =>{
                        if (x.includes('g')||x.includes('s')) {
                            return false;
                        }
                        return true;
                    }));
                    viewModel.column_display_presets().hide_parts().shown_columns(originalOrder.map((x) => {
                        if (x.includes('p')) {
                            return false;
                        }
                        return true;
                    }));
                    viewModel.column_display_presets().custom().shown_columns(originalOrder.map((x) => true));
                    viewModel.passcode(exam_object.navigation.csvEncryptionKey);
                }
            };
            
            examData.set_exam_details_from_json()

            
            ko.applyBindings(viewModel,document.getElementById('data_display'));
        </script>
	</body>
</html>
