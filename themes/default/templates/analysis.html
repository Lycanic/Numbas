<!DOCTYPE html>
<!--
Copyright 2023 Newcastle University

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<html lang="{{options.locale}}">
    <head>
        {% with dont_start_exam = True %}
        {% include 'head.html'  %}
        {% endwith %}
	</head>
	
    <body>
        <div id = data_display>
        <label for="student_results">Choose student results files</label> <!--data=document.querySelector('student_results').files[0], await data.text()-->
        
        <input type="file"
        id="student_results" name="student_results"
        accept=".txt" multiple data-bind="event: {change: function() {add_files($element.files)}}"> <!--file_array.push($element.files[0])-->

        <button data-bind = "click: download_decrypted_files">Download Decrypted Files</button>

        <table>
            <tr data-bind = "foreach: table_header"><th data-bind="text: $data"></th></tr>
            <tbody data-bind = "foreach: table_body">
                <tr data-bind = "foreach: $data">
                    <td data-bind = "text: $data"></td>
                </tr>
            </tbody>
        </table>


        <!-- <ul data-bind="foreach: attempts">
            <li><span data-bind="text: student_name"></span></li>
        </ul> -->

        </div>
        <script>
            Numbas.init(); //causes an error on lightbox.addEventListener, but seems to work anyway
            const examData = {
                exam: Numbas.exam,
                // getHeaders: function() {
                //     exam = this.exam;
                //     let originalOrder = [R('exam.csv.question key'),R('exam.csv.student name'),R('exam.csv.total score')]; //duplicated from exam.js, could this be cleaner?
                //     exam.question_groups.forEach((groupObject) => {
                //         groupObject.
                //     });

                //     //Ideas:
                //     //Use groupObject.createQuestion(n,false) to obtain all question objects
                //     //not yet sure

                //     this.questionList.forEach((questionObject) => {
                //         let questionKey = questionObject.number;
                //         let questionName = questionObject.name || (R('question') + + " " + questionKey);
                //         let groupName = R('exam.csv.group')+ " " + questionObject.group.number;
                //         let originalQuestionNumber = this.getOriginalPath(questionObject,"question");
                //         originalOrder.push(originalQuestionNumber);

                //         questionObject.parts.forEach((partObject) => {
                //             let partKey = partObject.index;
                //             let partName = partObject.name || (R('part') + " " + partKey);
                //             let partType = partObject.type;
                //             originalOrder.push(this.getOriginalPath(partObject,"part")+"m");
                //             if (partType != 'gapfill') {
                //                 originalOrder.push(this.getOriginalPath(partObject,"part")+"a");
                //             }

                //             partObject.gaps.forEach((gapObject) => {
                //                 let gapKey = gapObject.index;
                //                 let gapName = gapObject.name || (R('gap') + " " + gapKey);
                //                 let gapType = gapObject.type;
                //                 originalOrder.push(this.getOriginalPath(gapObject,"gap")+"m");
                //                 originalOrder.push(this.getOriginalPath(gapObject,"gap")+"a");
                //             });
                //             partObject.steps.forEach((stepObject) => {
                //                 let stepKey = stepObject.index;
                //                 let stepName = stepObject.name || (R('step') + " " + stepKey);
                //                 let stepType = stepObject.type;
                //                 originalOrder.push(this.getOriginalPath(stepObject,"step")+"m");
                //                 originalOrder.push(this.getOriginalPath(stepObject,"step")+"a");
                //             });
                //         });
                //     });
                //     let dataset = [originalOrder, groupRow, questionRow, partRow, gapRow, marksAnswerRow, expectedAnswers, studentAnswers];
                //     return Numbas.csv.from_array(dataset);
                // }
            };
            const viewModel = {
                uploaded_files: ko.observableArray(), //Note to self - to access this array, you need to do viewModel.file_array() (ie call it)
                decrypted_files: ko.observableArray(),
                add_files: async function(files) {
                    for (let file of files) {
                        this.uploaded_files.push(file);
                        let decrypted = await this.decrypt_file(file);
                        this.decrypted_files.push(decrypted);
                    }
                },
                decrypt_file: async function(file) {
                            let text = await Numbas.download.decrypt(Numbas.download.b64decode(await file.text()));
                            let filename = file.name.replace(".txt",".csv");
                            let content = this.parse_csv_to_arrays(text);
                            return {text: text,filename: filename,content: content}
                },
                download_decrypted_files: function() {
                    for (let file of this.decrypted_files()) {
                        Numbas.download.download_file(file.text, file.filename);
                    }
                },
                parse_csv_to_arrays: function(csv) {
                    let rows = Numbas.csv.split_csv_into_cells(csv);
                    return rows;
                },
                //currently a botch for the specific test data I have. Update when have exam details working
                table_header: ko.observableArray(["Question Key","Student Name","Total Score","r0q0","r0q0p0m","r0q0p0a","r0q1","r0q1p0m","r0q1p0a","r1q0","r1q0p0m","r1q0p0g0m","r1q0p0g0a","r1q0p0g1m","r1q0p0g1a","r1q0p1m","r1q0p1a"]),//ko.observableArray(examData.getHeaders())
            };

            viewModel.table_body = ko.computed(function() {
                    //needs to be initialised after the rest of viewModel so it can access decrypted_files()
                    let full_table = [];
                    for (let file of viewModel.decrypted_files()) {
                        file.content.forEach(data => full_table.push(data));
                    }
                    return full_table;
                }, this);


            // function parse_attempt(csv) {
            //     /* Take a CSV file's contents, and produce an Attempt object, storing student's name etc, and scores for questions and parts.
            //      */
            // }

            // function produce_table(attempts) {
            //     /* Given a list of attempts, produce a table summarising them.
            //        What kind of analysis do we want? 
            //        Teachers will want a total score for each student.
            //        Stretch goals:
            //        * summary stats (mean, range, etc)
            //        * Sort by score.
            //        * ???
            //     */
            // }


            // // how this would work in knockout:
            // const viewModel = {
            //     uploaded_files: ko.observableArray([]), // works like a normal array
            //     attempts: ko.observableArray([]),   // this could be computed based on uploaded_files, but tricky when properties on attmempts change
            // }
            // viewModel.analyse = function() {
            //     // make an Attempt for each uploaded_file;
            // }
            // viewModel.class_mean = ko.computed(function() {
            //     return mean(viewModel.attempts().map(a=>a.total_score()));
            // })

            // ko.applyBindings(viewModel, container_tag);

            // class Attempt {
            //     constructor(csv) {
            //         this.student_name = ko.observable(...);
            //         this.total_score = ko.observable(0):
            //         this.items = ko.observableArray([]); // one for each column representing a question or part
            //     }

            //     getItem(path) {
            //         // return a question/part based on its path, e.g. "q0p3".
            //     }
            // }

            
           ko.applyBindings(viewModel,document.getElementById('data_display'));
        </script>
	</body>
</html>
